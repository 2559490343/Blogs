## 生命周期钩子函数,  资源 assets 选项合并策略

#### 生命周期钩子函数的合并策略

在 Vue.js 中的生命周期钩子:
```javascript
var LIFECYCLE_HOOKS = [
        'beforeCreate',
        'created',
        'beforeMount',
        'mounted',
        'beforeUpdate',
        'updated',
        'beforeDestroy',
        'destroyed',
        'activated',
        'deactivated',
        'errorCaptured',
        'serverPrefetch'
    ];
```

接下来看, 每个生命周期的钩子的合并策略

```javascript
LIFECYCLE_HOOKS.forEach(function (hook) {
   strats[hook] = mergeHook;
});
```
通过 forEach() 函数, 为strats策略对象扩展对应的 hook, mergeHook 是一个函数,
所有生命周期钩子选项策略函数都是: mergeHook函数

mergeHook函数被调用是在: Vue.js初始化过程中 mergeOptions中被调用的, 检测到配置了这个生命周期的选项的钩子

mergeHook函数实现具体如下:
```javascript
function mergeHook( parentVal, childVal) {
    /*检测childVal是否有值*/
    var res = childVal
        ? parentVal  /*在childVal有值的的情况下, 在检测parentVal是否有值 */
            ? parentVal.concat(childVal)  /*两者都有值, 直接进行合并*/
            : Array.isArray(childVal)  /*childVal有值,parentVal没有值,判断childVal是否是数组 */
                ? childVal    /*是数组,直接返回*/
                : [childVal]  /*不是数组, 把childVal包装成一个数组*/
        : parentVal; /*如果childVal没有值,则直接把parentVal赋值给res*/
    return res
        ? dedupeHooks(res)
        : res
}
```
第一眼看上去, 这个函数挺复杂, 实际上是由三组三目运算符组成.
最终的目的就是把父子组件中的同名的钩子函数包装成一个数组,
在触发的该钩子函数时, 依次去调用数组里面的钩子函数

例如生命周期钩子 created(), 将会生成如下代码
```javascript
    let Parent = Vue.extend({
      created: function () {
        console.log('parent')
      }
    })
    let Child = new Parent({
      created: function () {
        console.log('child')
      }
    })
    /*打印*/
    console.log(Child.$options)
    可以看到created选项,把父子组件的created合并成了一个数组. 为了就是在触发created时机, 依次调用
```
阅读 mergeHook 函数, 发现一段有趣的代码: Array.isArray(childVal),原来生命周期钩子函数还可以这样写:
```javascript
const vm = new Vue({
    el: "#app",
    created:[
        function () {
            console.log("1")
        },
        function () {
            console.log("2")
        },
        function () {
            console.log("3")
        }
    ],
    ...
})
```

#### 资源 assets 选项自定义策略

最早接触 Vue 的时候,什么是资源一直很蒙, 后来才明白. 在 Vue 中的资源是指: component, directive ,filter
为什么说这些叫资源呢?  哈哈, 原因很简单, 因为让第三方进行配置

Vue 的中资源:
```javascript
var ASSET_TYPES = [
    'component',
    'directive',
    'filter'
];

ASSET_TYPES.forEach(function (type) {
       strats[type + 's'] = mergeAssets;
});
```
ASSET_TYPES函数, 进行forEach编译, 在ASSET_TYPES数组中的每个 key 后面加上个 s,
为什么没有直接加s呢?
- ASSET_TYPES里的资源在 Vue 中源码很多的地方都可以用到, 例如 component 内置组件等

接下里看看 mergeAssets 的实现, 和 mergeHook 的实现原理差不多
```javascript
function mergeAssets( parentVal, childVal, vm, key ) {
    /*创建res对象, 原型指向parentVal, 如果parentVal不存在就是null */
     var res = Object.create(parentVal || null);
     if (childVal) {
         assertObjectType(key, childVal, vm);
         /*把childVal的属性扩展到res上*/
         return extend(res, childVal)
     } else {
         return res
     }
}
```
从上面的代码可以分析出:  资源的合并是采用原型链的的形式进行关联的, 创建 res 对象, 把原型指向parentVal,
最终把 childVal 的属性扩展到 res 上.

到此明白一件事事情:
```html
<KeepAlive></KeepAlive>
<transition></transition>,
<transition-group></transition-group>
```
我们从来没自定义过该组件, 在每个组件中都有可使用.他们定义在组件的原型链的最顶层,
原型链的最顶层是: Vue.options.components, components 是一个对象,里面定义了内置组件

```javascript
Vue.options = {
	components: {
	  KeepAlive,
	  Transition,
	  TransitionGroup
	},
	directives: Object.create(null),
	directives:{
	  model,
	  show
	},
	filters: Object.create(null),
	_base: Vue
}

```

